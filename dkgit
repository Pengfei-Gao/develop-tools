#!/bin/bash

source $(dirname $0)/deps/commmon.sh

MODULE_NAME=$(basename $(pwd))

DEPLOY_INI=$(dirname $0)/conf/dkgit.ini 

DEVELOP_BRANCH=$(config $DEPLOY_INI branch develop)
PREVIEW_BRANCH=$(config $DEPLOY_INI branch preview)
RELEASE_BRANCH=$(config $DEPLOY_INI branch release)
CONFLICT_FLAG=$(config $DEPLOY_INI conflict conflict_flag)
IS_CLEAR=false

PROTECT_BRANCH=(
    $DEVELOP_BRANCH 
    $PREVIEW_BRANCH 
    $RELEASE_BRANCH
) 

ACTION_LIST=(
    deploy
    clean
    checkout
    sync
    review
    help
)

function error_log(){
    echo -en "\\033[1;31m$*\\033[m"
}

function warn_log(){
  echo -en "\\033[3;38;5;206m$*\\033[m"
}

function info_log(){
  echo -en "\\033[32m$*\\033[m"
}

function in_array(){
    local value=$1   # å…¥å‚ å€¼
    local arr=${@:2} # å…¥å‚ æ•°ç»„
    for var in ${arr[@]} ; do
        [ "$(echo $var | trim)" = "$(echo $value | trim)" ] && return 0
    done
    return 1
}

# è·å–å½“å‰åˆ†æ”¯å
function get_current_branch_name(){
    echo $(git symbolic-ref --short HEAD)
}

# æ£€æµ‹å½“å‰åˆ†æ”¯æ˜¯å¦åˆæ³•
function check_branch_valid(){
    local branch_name=$1   # å…¥å‚ï¼Œåˆ†æ”¯åç§°
    info_log "å¼€å§‹å‘å¸ƒåˆ° $MODE åˆ†æ”¯...\n"
    while in_array "$branch_name" ${PROTECT_BRANCH[@]} || ! in_array "$branch_name" "$(git branch)"; do
        error_log "ğŸ˜¨ å½“å‰æˆ–é€‰æ‹©çš„åˆ†æ”¯ä¸º $branch_name , è¯¥åˆ†æ”¯ä¸å­˜åœ¨æˆ–å—åˆ°ä¿æŠ¤ï¼Œè¯·é€‰æ‹©åˆé€‚çš„åŠŸèƒ½åˆ†æ”¯æ¥å‘å¸ƒï¼š\n "
        echo "$(git branch)"
        printf "ğŸ™„ è¯·è¾“å…¥åˆæ³•çš„åˆ†æ”¯åï¼š"
        read branch_name
    done
    

    warn_log "ğŸ‘¹ å½“å‰åˆ†æ”¯ ($branch_name) ä¿®æ”¹å¯¹æ¯” $MODE  å¦‚ä¸‹ï¼š\n"
    show_diff_stat $branch_name $(config $DEPLOY_INI branch $(echo $MODE | tr '[A-Z]' '[a-z]'))


    local continue=y
    warn_log "ğŸ‘¹ ç¡®å®šè¦ç»§ç»­å‘å¸ƒ $branch_name åˆ° $MODE åˆ†æ”¯ï¼ˆy/nï¼‰ï¼Ÿ"
    read continue
    [ "$continue" = "n" ] && {
        info_log "ğŸ˜Œ å¼€å§‹é‡æ–°é€‰æ‹©ç›®æ ‡åŠŸèƒ½åˆ†æ”¯.........\n" 
        check_branch_valid
    } || {
        info_log "ğŸ‘¹ğŸ‘» ç»§ç»­å‘å¸ƒé€‰ä¸­çš„ $branch_name åˆ° $MODE åˆ†æ”¯"
    }

    git checkout $branch_name && info_log "ğŸ˜ åˆ†æ”¯åˆ‡æ¢æˆåŠŸï¼\n" || { 
        error_log "ğŸ˜° å®Œè›‹äº†ï¼Œåˆ†æ”¯åˆ‡æ¢å¤±è´¥äº†, æœ‰å¯èƒ½æ˜¯å½“å‰åˆ†æ”¯æœ‰æ”¹åŠ¨æœªæäº¤å¯¼è‡´çš„ï¼Œæäº¤åé‡è¯•ä¸€ä¸‹å§...\n"
        exit
    }
}

# æ‹‰å–ä¸Šæ¸¸åˆ†æ”¯ï¼Œå¹¶ä¸”é‡ç½®åŸºçº¿ï¼ˆä»¥ä¸Šæ¸¸åˆ†æ”¯ä¸ºå‡†ï¼‰
function fetch_and_reset_hard(){
    local branch_name=$(get_current_branch_name)
    info_log "ğŸ˜ˆ å¼€å§‹æ‹‰å–åŒæ­¥ä¸Šæµåˆ†æ”¯ (git fetch)...\n"
    { 
        git fetch && git reset origin/$branch_name --hard 
    } && {
        info_log "ğŸ‘» æ‹‰å–åŒæ­¥åˆ†æ”¯æˆåŠŸ (git reset origin/$branch_name --hard) ï¼\n"
    } || {
        error_log "ğŸ˜¨ æ‹‰å–åŒæ­¥å¤±è´¥ï¼Œå¼€å§‹é‡è¯•... \n"
        fetch_and_reset_hard
    }
}

function push_branch(){
    desc_branch=$1
    git push && {
        info_log "ğŸ˜ˆ å¼€å§‹æäº¤ä»£ç åˆ° $desc_branch...(git push)  \n" 
    } && {
        info_log "ğŸ‘» å‘å¸ƒæˆåŠŸ...  \n" 
    } || {
        info_log "ğŸ˜° å‘å¸ƒå¤±è´¥...å¼€å§‹é‡è¯•  \n"
    }
}


function handle_unmerged_file(){
    for file in $(git ls-files --unmerged | awk -F " " '{print $4}' | sort | uniq); do
        info_log "å¼€å§‹åˆå¹¶ $file .... \n"
        for ((;;)); do
            vim $file +/"$CONFLICT_FLAG"
            info_log "æ–‡ä»¶ $file åˆå¹¶åçš„diffå±•ç¤ºå¦‚ä¸‹ï¼š\n"
            git diff $file
            info_log "è¯¥æ–‡ä»¶æ˜¯å¦åˆå¹¶å®Œæˆ (y/n)?"
            read right
            [ "$right" == "y" ] && {
                break
            }
        done
        git add $file
    done
}

# åˆå¹¶åŠŸèƒ½åˆ†æ”¯ï¼Œå¹¶ä¸”å‘å¸ƒ
function merge_and_publish(){
    local desc_branch=$1        # å…¥å‚,ç›®æ ‡åˆ†æ”¯ develop master preview
    local function_branch=$2    # å…¥å‚åŠŸèƒ½åˆ†æ”¯
    
    git checkout $function_branch && {
        info_log "ğŸ˜ˆ å¼€å§‹åŒæ­¥è¿œç«¯çš„ remote/origin/$function_branch...(git checkout $function_branch)  \n"
        fetch_and_reset_hard
    } || {
        error_log "ğŸ˜¨ åˆ†æ”¯ $function_branch  åˆ‡æ¢æˆ–å¤±è´¥ï¼Œè¯·å°†æœ¬åœ°ä¿®æ”¹æäº¤æˆ–æš‚å­˜åé‡è¯•"
        exit
    }
    
    git checkout $desc_branch && {
        info_log "ğŸ˜ˆ å¼€å§‹åŒæ­¥è¿œç«¯çš„ remote/origin/$desc_branch...(git checkout $desc_branch)  \n"
        fetch_and_reset_hard
    } || {
        error_log "ğŸ˜¨ åˆ†æ”¯ $function_branch  åˆ‡æ¢æˆ–å¤±è´¥ï¼Œè¯·å°†æœ¬åœ°ä¿®æ”¹æäº¤æˆ–æš‚å­˜åé‡è¯•"
        exit
    }

    git merge $function_branch && {
        info_log "ğŸ˜ˆ å¼€å§‹åˆå¹¶{$function_branch -> $desc_branch}... (git merge $function_branch) \n" &&
        git merge $function_branch
    } || {
        error_log "ğŸ˜¨ åˆå¹¶åˆ†æ”¯{$function_branch -> $desc_branch} å¤±è´¥, å¼€å§‹è§£å†³å†²çªï¼š"
        handle_unmerged_file
        git merge --continue
        exit
    }
    
    push_branch $desc_branch
}

function stash_local_modify(){
    stash_success=1
    if [ -n "$(git status -s)" ]; then
        info_log "ğŸ˜‡ æ£€æµ‹åˆ°æœ¬åœ°ä¿®æ”¹ï¼Œæš‚æ—¶å‹å…¥æš‚å­˜æ ˆ \n"
        git stash
        stash_success=0
    fi
}

function pop_local_stash_modify(){
    if [ $stash_success -eq 0 ]; then
        info_log "ğŸ˜‡ ä»æš‚å­˜æ ˆå¼¹å‡ºæœ¬åœ°ä¿®æ”¹.... \n"
        git stash pop
    fi
}

# å’Œä¸Šæ¸¸åˆ†æ”¯å¯¹é½ï¼ŒåŒæ­¥remote/origin/master
function fetch_and_rebase_master(){
    stash_local_modify
    info_log "ğŸ˜ˆ å¼€å§‹åŒæ­¥ä¸»åˆ†æ”¯...(git fetch && git rebase -i origin/master)\n"
    git fetch  && git rebase -i origin/master && {
        info_log "ğŸ‘¹ğŸ‘º  åŒæ­¥masteræˆåŠŸ... \n"
        info_log "ğŸ‘¹ğŸ‘º  å¼ºåˆ¶æ›´æ–°å½“å‰åˆ†æ”¯... \n"
        git push -f
        info_log "ğŸ‘» ä¸»å¹²æ›´æ–°æˆåŠŸ... \n"
    } || {
        error_log "ğŸ˜– å®Œè›‹äº†ï¼ŒåŒæ­¥ä¸»åˆ†æ”¯å¤±è´¥ï¼Œå¯èƒ½æ˜¯äº§ç”Ÿäº†å†²çªï¼Œå¼€å§‹è§£å†³å†²çª:"
        handle_unmerged_file
        git rebase --continue || git rebase --skip
    }
    pop_local_stash_modify
}

# å°†ä»£ç å‘å¸ƒåˆ°æµ‹è¯•æœº(åˆå¹¶åˆ°develop)
function publish_develop(){
    check_branch_valid $(get_current_branch_name)
    fetch_and_reset_hard                                             # æ‹‰å–å¹¶é‡ç½®åˆ°è¿œç¨‹åˆ†æ”¯
    #fetch_and_rebase_master                                          # åŒæ­¥master
    merge_and_publish $DEVELOP_BRANCH $(get_current_branch_name)     # åˆå¹¶å¹¶å‘å¸ƒ
}

# å°†ä»£ç å‘å¸ƒåˆ°é¢„è§ˆæœºå™¨(åˆå¹¶åˆ°preview)
function publish_preview(){
    check_branch_valid $(get_current_branch_name)
    fetch_and_reset_hard $(get_current_branch_name)
    #fetch_and_rebase_master
    merge_and_publish $PREVIEW_BRANCH $(get_current_branch_name)     # åˆå¹¶å¹¶å‘å¸ƒ
}

# å°†ä»£ç å‘å¸ƒåˆ°ç”Ÿäº§ç¯å¢ƒ(åˆå¹¶åˆ°master)
function publish_production(){
    check_branch_valid $(get_current_branch_name)
    fetch_and_reset_hard $(get_current_branch_name)
    fetch_and_rebase_master
    merge_and_publish $RELEASE_BRANCH $(get_current_branch_name)     # åˆå¹¶å¹¶å‘å¸ƒ
}


function show_usage(){
    cat $(dirname $0)/assets/usage_dkgit
    exit;
}


# å¼ºåˆ¶æŒ‡å®šåˆ†æ”¯å’Œmasterå¯¹é½
function clean_branch(){
    local branch=$1
    [ -z "$branch_name" ] && {
        local branch=$(get_current_branch_name)
    }
    while ! in_array "$branch" ${PROTECT_BRANCH[@]} || ! in_array "$branch" "$(git branch)"; do
        error_log "ğŸ˜¨ å½“å‰æˆ–é€‰æ‹©çš„åˆ†æ”¯ä¸º $branch , è¯¥åˆ†æ”¯ä¸å­˜åœ¨æˆ–å—åˆ°ä¿æŠ¤ï¼Œclean åŠŸèƒ½ä»…é™åœ¨ ${PROTECT_BRANCH[@]} åˆ†æ”¯ä¸Šä½¿ç”¨ï¼š\n "
        echo "$(git branch)"
        printf "ğŸ™„ è¯·è¾“å…¥åˆæ³•çš„åˆ†æ”¯åï¼š"
        read branch_name
    done
    warn_log "ğŸ‘¹ ç¡®å®šè¦å°† $branch åˆ†æ”¯å¼ºåˆ¶resetåˆ°  origin/master (y/n) ?"
    read reset_hard
    if [ $reset_hard = "n" ]; then
        info_log "ğŸ˜´ é€€å‡º clean æ“ä½œ..."
        exit
    fi
    info_log "ğŸ˜ˆ å¼€å§‹å¯¹é½ $branch åˆ°ä¸»å¹²... \n"
    {
        git checkout $branch &&
        git fetch  &&
        git reset origin/master --hard  &&
        git push -f --set-upstream origin $branch
    } && { 
        info_log "ğŸ‘» å¯¹é½æˆåŠŸ... \n"
    } || {
        error_log "ğŸ˜° å¯¹é½å¤±è´¥ï¼Œå¼€å§‹é‡è¯•... \n"
        clean_branch $branch
    }
}

function show_diff_stat(){
    local origin=$1
    local compire=$2
    if [ -z "$compire" ]; then
        local compire="origin/master"
    fi
    git diff --stat $origin $compire
}



function publish_branch(){
    [ -z $MODE ] && show_usage
    case $MODE in
        DEVELOP)
            publish_develop
            ;;
        PREVIEW)
            publish_preview
            ;;
        RELEASE)
            #publish_production
            ;;
    esac
}

function checkout_remote_origin_branch(){
    local branch_name=$1
    [ -z "$branch_name" ] && {
        error_log "è¯·ä½¿ç”¨ -b å‚æ•°æŒ‡å®šå…·ä½“åˆ†æ”¯... \n"
        show_usage
    }
    stash_local_modify # å°†æœ¬åœ°ä¿®æ”¹å‹å…¥æš‚å­˜
    info_log "ğŸ˜ˆ å¼€å§‹æ‹‰å–è¿œç¨‹åˆ†æ”¯.(git fetch)... \n"
    if git fetch; then
        info_log "ğŸ‘¹ æ‹‰å–æˆåŠŸ,å¼ºåˆ¶æ£€å‡ºåˆ° origin/$branch_name...(git reset origin/$branch_name --hard).... \n"
        if in_array $branch_name $(git branch) ; then
            info_log "ğŸ˜ˆ æ£€å‡ºå·²å­˜åœ¨çš„åˆ†æ”¯$branch_name... git checkout $branch_name && git reset origin/$branch_name --hard ...... \n"
            git checkout $branch_name
            git reset origin/$branch_name --hard
        else
            warn_log "ğŸ™„ è¾“å…¥çš„åˆ†æ”¯ $branch_name  ä¸å­˜åœ¨ï¼Œæ˜¯å¦éœ€è¦åˆ›å»ºæ–°åˆ†æ”¯(y/n)?"
            read create_branch
            [ "$create_branch" == "y" ] && {
                info_log "ğŸ˜¡ åˆ›å»ºæ–°åˆ†æ”¯ $branch_name ... git checkout -b $branch_name ...... \n"
                git checkout -b $branch_name
            }
        fi
        
        if [ ! -z "$(git submodule status --)" ]; then
            info_log "æ›´æ–°å­æ¨¡å—..........\n"
            git submodule init
            git submodule update
        fi

        [ $? -eq 0 ] && info_log "ğŸ‘» æ£€å‡ºæˆåŠŸ......... \n" || info_log "ğŸ˜¨æ£€å‡ºå¤±è´¥....\n"
    else
        error_log "ğŸ˜° æ£€å‡ºå¤±è´¥,å¼€å§‹é‡è¯•... \n"
        checkout_remote_origin_branch $branch_name
    fi
    pop_local_stash_modify
}

function rebase_remote_origin_branch(){
    local branch_name=$1
    info_log "ğŸ˜ˆ å¼€å§‹æ‹‰å–è¿œç¨‹åˆ†æ”¯.(git fetch)... \n"
    git fetch && {
        info_log "ğŸ‘¹ æ‹‰å–æˆåŠŸ,å¼ºåˆ¶æ£€å‡ºåˆ° origin/$branch_name...(git reset origin/$branch_name --hard).... \n"
        git rebase -i origin/$branch_name && 
        info_log "ğŸ‘» åŒæ­¥æˆåŠŸ......... \n" || 
        error_log "ğŸ˜° åŒæ­¥å¤±è´¥,å¼€å§‹é‡è¯•... \n"
    } || {
        error_log "ğŸ˜° åŒæ­¥å¤±è´¥,å¼€å§‹é‡è¯•... \n"
        checkout_remote_origin_branch $branch_name
    }
}


function commit_local_changes(){
    info_log "ğŸ¤’ æœ¬åœ°ä¿®æ”¹å¦‚ä¸‹ï¼š"
    git diff
    warn_log "æ˜¯å¦ç»§ç»­æäº¤(y/n)ï¼Ÿ"
    read is_commit
    if [ "$is_commit" != "n" ]; then
        git add .
    else
        info_log "é€€å‡ºæäº¤æµç¨‹..."
        exit
    fi
    if [ -z "$COMMIT_MSG" ]; then
        git commit 
    else
        git commit -m "$COMMIT_MSG"
    fi
    git push  --set-upstream origin $(get_current_branch_name)
}

# æ£€æŸ¥æ˜¯å¦æ˜¯gitç›®å½•
function must_be_git_project(){
    if git status ;  then
        return 1
    else
        error_log "ğŸ¤£ å½“å‰ç›®å½•ä¸æ˜¯ä¸€ä¸ªåˆæ³•çš„gitç›®å½•......."
        return 0
    fi
}


function init_args(){
    while getopts "dprchb:m:" arg
    do
        case $arg in
            d) 
                MODE="DEVELOP"  
                ;;
            p) 
                MODE="PREVIEW"  
                ;;
            #r) 
            #    MODE="RELEASE"  
            #    ;;
            c) 
                IS_CLEAR=true 
                ;;
            h) 
                show_usage
                ;;
            m) 
                COMMIT_MSG=${@:2}
                ;;
            b) 
                TARGET_BRANCH_NAME=$OPTARG
                ;;
            ?)  
                show_usage
                ;;
        esac
    done
}




# åˆå§‹åŒ–å‚æ•°
ACTION=$1
in_array "$ACTION" ${ACTION_LIST[@]} &&  init_args ${@:2}

[ -z "$ACTION" ] && {
    show_usage
}

case $ACTION in
    deploy)
        must_be_git_project && exit
        publish_branch
        ;;
    clean)
        must_be_git_project && exit
        clean_branch $(get_current_branch_name)
        ;;
    checkout)
        must_be_git_project && exit
        [ -z "$TARGET_BRANCH_NAME" ] && TARGET_BRANCH_NAME=$2
        checkout_remote_origin_branch $TARGET_BRANCH_NAME
        ;;
    sync)
        must_be_git_project && exit
        fetch_and_rebase_master
        ;;
#    commit)
#        must_be_git_project && exit
#        commit_local_changes
#        ;;
    review)
        must_be_git_project && exit
        show_diff_stat $(get_current_branch_name) $TARGET_BRANCH_NAME
        ;;
    help)
        show_usage
        ;;
    *)  
        git "${@:1}"
        ;;
esac

